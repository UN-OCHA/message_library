<?php

/**
 * Implements hook_init().
 */
function search_highlight_init() {
  drupal_add_js(drupal_get_path('module', 'search_highlight') . '/js/search_highlight.js');
  drupal_add_css(drupal_get_path('module', 'search_highlight') . '/css/search_highlight.css');
}


/**
 * Implements hook_theme().
 * @param $existing
 * @param $type
 * @param $theme
 * @param $path
 * @return unknown_type
 */
function search_highlight_theme($existing, $type, $theme, $path) {
  return array(
    'search_highlight_links' => array(
      'template' => 'templates/search_highlight_links',
      'variables' => array(
        'prev_link' => '',
        'next_link' => '',
      ),
    ),
  );
}


/**
 * Implements hook_views_api().
 */
function search_highlight_views_api() {
  return array(
    'api' => 2,
  );
}


/**
 * Implements hook_views_pre_execute().
 */
function search_highlight_views_pre_execute(&$view) {
  if (in_array($view->name, variable_get('prev_next_iaa_views_enabled', array()))) {
    views_include_handlers();
    $query = db_rewrite_sql($view->build_info['query'], $view->base_table, $view->base_field, array('view' => &$view));
    $args = $view->build_info['query_args'];
    /*_db_query_callback($view->build_info['query_args'], TRUE);
     $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
     */
    // TODO Please convert this statement to the D7 database API syntax.
    $result = db_query($query, $args);
    $highlight = array();
    $previous = 0;
    $highlight_words = array();
    $highlight_words_text = '';
    if (isset($_SESSION['views']['message_library']['default'])) {
      $viewsarg = $_SESSION['views']['message_library']['default'];
      foreach ($viewsarg as $varg => $vval) {
        if ($varg != 'text' && $varg != 'title') {
          $term = taxonomy_term_load($vval);
          $highlight_words[] = htmlentities($term->name);
        }
        else if ($varg == 'title') {
          $node = node_load($vval);
          $highlight_words[] = htmlentities($node->title);
        }
        else {
          $highlight_words_text .= $vval;
          $hword = explode(" ", $vval);
          foreach ($hword as $w) {
            //if (strlen($w) >= 3) {
            $highlight_words[] = htmlentities($w);
            //}
          }
        }
      }
    }

    // vu qu'on passe par des nodes références, et que la valeur "delta" de views ne fonctionne pas, on doit trier le tableau des résultats... Views est vraiment de la merde...
    $messages = array();
    $messagesSorted = array();
    $threatOrder = array();
    while ($item = db_fetch_array($result)) {
      if (!in_array($messages[$item['node_node_data_field_message_threat_nid']], $threatOrder)) {
        $threatOrder[] = $item['node_node_data_field_message_threat_nid'];
      }
      $messages[$item['node_node_data_field_message_threat_nid']][] = $item;
    }

    foreach ($threatOrder as $threatKey) {
      foreach ($messages[$threatKey] as $m) {
        $messagesSorted[] = $m;
      }
    }


    foreach ($messagesSorted as $item) {
      //echo "<pre>";print_r($item);echo "<pre>";die;
      /*// Node = threat
       $messageId = $item['node_node_data_field_threat_message_nid'];
       $messageLink = url('node/'.$item['nid']).'#'.$messageId;
       */
      $messageId = $item['nid'];
      $messageLink = url('node/' . $item['node_node_data_field_message_threat_nid']) . '#' . $messageId;
      $prev_link = '';
      if (isset($highlight[$previous]['link'])) {
        $prev_link = $highlight[$previous]['link'];
        $highlight[$previous]['next_link'] = $messageLink;
      }
      $highlight[$messageId] = array(
        'prev_link' => $prev_link,
        'link' => $messageLink,
      );
      $previous = $messageId;
    }
    $_SESSION['search_highlight_object'] = serialize($view);
    $_SESSION['search_highlight'] = $highlight;
    $_SESSION['search_highlight_words'] = $highlight_words;
    $_SESSION['search_highlight_words_text'] = $highlight_words_text;
  }
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function search_highlight_get_links($nid) {
  $output = '';
  $prev_link = $_SESSION['search_highlight'][$nid]['prev_link'];
  $next_link = $_SESSION['search_highlight'][$nid]['next_link'];

  if ($prev_link != '' || $next_link != '') {
    $output = theme("search_highlight_links", array('prev_link' => $prev_link, 'next_link' => $next_link));
  }
  return $output;
}



/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function search_highlight_content($content) {
  if (isset($_SESSION['search_highlight_words']) && !empty($_SESSION['search_highlight_words'])) {
    $highlights = $_SESSION['search_highlight_words'];
    foreach ($highlights as $highlight) {
      if ($highlight != '') {
        // on echappe les caractères regexp
        $highlight = str_replace(array('\\', '/', '?', '.', '*', '+', '-', '(', ')', '[', ']', '^', '$', '{', '}', '|'), array('\\\\', '\/', '\?', '\.', '\*', '\+', '\-', '\(', '\)', '\[', '\]', '\^', '\$', '\{', '\}', '\|'), $highlight);
        //$pattern = '/\b('.$highlight.')\b(?=[^><]*<|.$)/i'; // recherche texte strict + "/(\w*?(?:$keywordsPattern)\w*)/ui" si highlight mot complet
        $pattern = '/\b(' . search_highlight_format_term($highlight) . ')\b(?=[^><]*<|.$)/i'; // recherche texte non strict
        $replacement = '<span class="search_highlight">\1</span>';
        // on passe par un <div> car j'arrive pas à faire l'expression régulière correctement
        $content_div = preg_replace($pattern, $replacement, '<div>' . $content . '</div>');
        $content = substr($content_div, 5, -6);
      }
    }
  }
  return $content;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function search_highlight_format_term($term) {
  return str_replace(array('(', ')'), array('\(', '\)'), $term);
}


/*function search_highlight_views_pre_render (&$view) {
 foreach ($view->result as $key => &$data) {
 foreach ($data as $key1 => &$data1) {
 if ($key1 == 'node_title' || strpos($key1,'node_node_data') === 0) {
 //$view->result[$key]->$key1 = search_highlight_content($data1);
 $data1 = search_highlight_content($data1);
 }
 }
 }
 }*/


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function search_highlight_excerpt($text, $keys = '') {
  if ($keys == '' && isset($_SESSION['search_highlight_words'])) {
    foreach ($_SESSION['search_highlight_words'] as $hword) {
      $keys .= $hword . " ";
    }
  }
  // We highlight around non-indexable or CJK characters.
  $boundary = '(?:(?<=[' . PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK . '])|(?=[' . PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK . ']))';

  // Extract positive keywords and phrases
  preg_match_all('/ ("([^"]+)"|(?!OR)([^" ]+))/', ' ' . $keys, $matches);
  $keys = array_merge($matches[2], $matches[3]);

  // Prepare text
  $text = ' ' . strip_tags(str_replace(array('<', '>'), array(' <', '> '), $text)) . ' ';
  array_walk($keys, '_search_excerpt_replace');
  $workkeys = $keys;

  // Extract a fragment per keyword for at most 4 keywords.
  // First we collect ranges of text around each keyword, starting/ending
  // at spaces.
  // If the sum of all fragments is too short, we look for second occurrences.
  $ranges = array();
  $included = array();
  $length = 0;
  while ($length < 256 && count($workkeys)) {
    foreach ($workkeys as $k => $key) {
      if (strlen($key) == 0) {
        unset($workkeys[$k]);
        unset($keys[$k]);
        continue;
      }
      if ($length >= 256) {
        break;
      }
      // Remember occurrence of key so we can skip over it if more occurrences
      // are desired.
      if (!isset($included[$key])) {
        $included[$key] = 0;
      }
      // Locate a keyword (position $p), then locate a space in front (position
      // $q) and behind it (position $s)
      if (preg_match('/' . $boundary . $key . $boundary . '/iu', $text, $match, PREG_OFFSET_CAPTURE, $included[$key])) {
        $p = $match[0][1];
        if (($q = strpos($text, ' ', max(0, $p - 60))) !== FALSE) {
          $end = substr($text, $p, 80);
          if (($s = strrpos($end, ' ')) !== FALSE) {
            $ranges[$q] = $p + $s;
            $length += $p + $s - $q;
            $included[$key] = $p + 1;
          }
          else {
            unset($workkeys[$k]);
          }
        }
        else {
          unset($workkeys[$k]);
        }
      }
      else {
        unset($workkeys[$k]);
      }
    }
  }

  // If we didn't find anything, return the beginning.
  if (count($ranges) == 0) {
    return truncate_utf8($text, 256, true) . ' [...]';
  }

  // Sort the text ranges by starting position.
  ksort($ranges);

  // Now we collapse overlapping text ranges into one. The sorting makes it O(n).
  $newranges = array();
  foreach ($ranges as $from2 => $to2) {
    if (!isset($from1)) {
      $from1 = $from2;
      $to1 = $to2;
      continue;
    }
    if ($from2 <= $to1) {
      $to1 = max($to1, $to2);
    }
    else {
      $newranges[$from1] = $to1;
      $from1 = $from2;
      $to1 = $to2;
    }
  }
  $newranges[$from1] = $to1;

  // Fetch text
  $out = array();
  foreach ($newranges as $from => $to) {
    $out[] = substr($text, $from, $to - $from);
  }
  $text = (isset($newranges[0]) ? '' : '[...] ') . implode(' [...] ', $out) . ' [...]';

  // Highlight keywords. Must be done at once to prevent conflicts ('strong' and '<strong>').
  $text = preg_replace('/' . $boundary . '(' . implode('|', $keys) . ')' . $boundary . '/iu', '<span class="search_highlight">\0</span>', $text);
  return $text;
}
