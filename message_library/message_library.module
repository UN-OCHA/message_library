<?php
/**
 * @file
 * Code for the Message Libarary feature.
 */
include_once 'message_library.features.inc';

/**
 * Implementation of hook_form_alter()
 *
 * Change the default placeholders for the (-Any-) options on the exposed filter
 */
function message_library_form_alter(&$form, $form_state, $form_id) {
  if(!empty($form_state['view']) && $form_state['view']->name == 'message_library') {
    // overrides <All> on the dropdown
    if (!empty($form['target_audience']['#options'])) {
      $form['target_audience']['#options']['All'] = t('<All target Audience>');
    }
    if (!empty($form['at_risk_group']['#options'])) {
      $form['at_risk_group']['#options']['All'] = t('<All groups>');
    }
    if (!empty($form['issue']['#options'])) {
      $form['issue']['#options']['All'] = t('<All issues>');
    }
    if (!empty($form['threat']['#options'])) {
      $form['threat']['#options']['All'] = t('<All threats>');
    }

    $form['ml_search_text']['#attributes'] = array('class' => array('ctools-auto-submit-exclude'));
  }
}

/**
 * Implements hook_menu().
 *
 * Creates a 'Message Library' section on the administration page
 */
function message_library_menu() {
  $items['admin/config/message_library'] = array(
    'title' => 'Message Library',
    'description' => 'Settings for the Message Library.',
    'position' => 'right',
    'weight' => -10,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer site configuration'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  return $items;
}

/**
 * Implements hook_views_pre_execute()
 */
function message_library_views_pre_execute(&$view) {
  return;
  // @todo: it's will be good when the Solr sever is not accessible, or the
  // message_library_index not available, it still can work gracefully.
  $solr_server = search_api_server_load('solr_server');
  if ((!empty($solr_server)) && ($solr_server instanceof SearchApiServer)) {
    $solr_service = new SearchApiSolrService($solr_server);

    if (!$solr_service->ping()) {
      //
    }
  }
}

/**
 * Implements hook_page_alter()
 */
function message_library_page_alter(&$page) {
  // Set breadcrumb for the Message Library
  if (current_path() == 'message-library') {
    drupal_set_breadcrumb(array(
      l('Home', '<front>'),
      l('Resources', 'resources'),
      l('Communication Tools', 'resources/communication-tools'),
    ));
  }

  // Set breadcrumb for the TOU page
  if (current_path() == 'message-library-cgi') {
    drupal_set_breadcrumb(array(
        l('Home', '<front>'),
        l('Resources', 'resources'),
        l('Communication Tools', 'resources/communication-tools'),
        l('Message Library', 'message-library'),
    ));
  }
}

/**
 * Implements hook_menu_breadcrumb_alter()
 */
function message_library_menu_breadcrumb_alter(&$active_trail, $item) {
  // @xxx: Why it doesn't work?
}
/**
 * Get all the threat terms under an issue
 * @return An array of all the threat tids
 */
function message_library_get_threat_by_issue($tid) {
  $terms = array();

  // Get all the sub-terms of this term
  $tids = array($tid);
  $vocab = taxonomy_vocabulary_machine_name_load('issues');
  if (!empty($vocab->vid)) {
    $vid = $vocab->vid;

    $items = taxonomy_get_tree($vid, $tid);
    if (!empty($items)) {
      foreach ($items as $item) {
        if (empty($item->tid)) continue;
        $tids[] = $item->tid;
      }
    }
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'threat')
    ->fieldCondition('field_threat_category', 'tid', $tids, 'IN');
  $result = $query->execute();

  if (!empty($result) && !empty($result['taxonomy_term'])) {
    $terms = array_keys($result['taxonomy_term']);
  }

  return $terms;
}

/**
 * Get all of the messages under a threat
 *
 * @return A collection of the nde ids of the messages
 */
function message_library_get_messages_by_threat_tid($tid) {
  $nids = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'message')
    ->fieldCondition('field_message_threat', 'tid', $tid)
    ->execute();

  if (!empty($result) && !empty($result['node'])) {
    $nids = array_keys($result['node']);
    if (!empty($nids)) {
      $nids = array_unique($nids);
    }
  }

  return $nids;
}

/**
 * Implements hook_pathauto()
 */
function message_library_pathauto($op) {
  switch ($op) {
    case 'settings':
      $settings = array();
      $settings['module'] = 'message_library';
      $settings['token_type'] = 'term';
      $settings['groupheader'] = t('Message library paths');
      $settings['patterndescr'] = t('Default path pattern (applies to all Message Library threat terms).');
      $settings['patterndefault'] = 'message-library/threat/[term:name]';
      $settings['batch_update_callback'] = 'message_library_pathauto_bulk_update_batch_process';

      // Threat
      $settings['patternitems']['ml_threat'] = t('Pattern for all Message Library threat terms.');
      // Message
      $settings['patternitems']['ml_message'] = t('Pattern for all Message Library message nodes.');

      return (object) $settings;
    default:
      break;
  }
}

/**
 * Implements hook_path_alias_types()
 *
 * Used primarily by the bulk delete form.
 */
function message_library_path_alias_types() {
  $objects['message-library/threat/'] = t("Message library threat terms");
  return $objects;
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function message_library_taxonomy_term_insert($term) {
  if (message_library_is_threat_term($term)) {
    message_library_threat_term_update_alias($term, 'insert');
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function message_library_taxonomy_term_update($term) {
  if (message_library_is_threat_term($term)) {
    message_library_threat_term_update_alias($term, 'update');
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function message_library_taxonomy_term_delete($term) {
  if (message_library_is_threat_term($term)) {
    $source = 'message-library/threat/' . $term->tid;
    pathauto_path_delete_all($source);
  }
}

/**
 * Callback for creating proper alias for threat page
 */
function message_library_threat_term_update_alias(stdClass $term, $op, array $options = array()) {
  $module = 'message_library';
  $source = 'message-library/threat/' . $term->tid;
  module_load_include('inc', 'pathauto');
  $alias = pathauto_create_alias($module, $op, $source, array('term' => $term), 'ml_threat');

  // if (!empty($alias)) {
  //   drupal_set_message(t('Alias created for term :term : :alias.', array(':term' => $term->name, ':alias' => $alias)));
  // }
  // else {
  //   drupal_set_message(t('Failed to create alias for term :term.', array(':term' => $term->name)), 'error');
  // }
}

/**
 * Check whehter a term belongs to vocabulary 'Threat'
 */
function message_library_is_threat_term($term) {
  if (!is_object($term) && is_numeric($term)) {
    $term = taxonomy_term_load($term);
  }
  $threat_vocab = taxonomy_vocabulary_machine_name_load('threat');
  if (!empty($threat_vocab->vid) && !empty($term->vid) && $threat_vocab->vid == $term->vid) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Batch processing callback; Generate aliases for message library content.
 */
function message_library_pathauto_bulk_update_batch_process(&$context) {
  if (!isset($context['sandbox']['current'])) {
    $context['sandbox']['count'] = 0;
    $context['sandbox']['current'] = 0;
  }

  $threat_tids = array();
  $threat_vocab = taxonomy_vocabulary_machine_name_load('threat');
  if (!empty($threat_vocab->vid)) {
    $terms = taxonomy_get_tree($threat_vocab->vid);
    if (!empty($terms)) {
      foreach ($terms as $term) {
        if (!empty($term->tid)) {
          $threat_tids[] = $term->tid;
        }
      }
    }
  }

  if (!empty($threat_tids)) {
    $context['sandbox']['total'] = count($threat_tids);
  }
  else {
    $context['finished'] = 1;
    return;
  }

  message_library_threat_term_update_alias_mutiple($threat_tids, 'bulkupdate');
  $context['sandbox']['count'] += count($threat_tids);
  $context['sandbox']['current'] = max($threat_tids);
  $context['message'] = t('Updated alias for term @tid.', array('@tid' => end($threat_tids)));

  if ($context['sandbox']['count'] != $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['count'] / $context['sandbox']['total'];
  }
}

/**
 * Update the URL aliases for multiple threat terms
 */
function message_library_threat_term_update_alias_mutiple(array $tids, $op, array $options = array()) {
  $options += array('message' => FALSE);

  $terms = taxonomy_term_load_multiple($tids);
  foreach ($terms as $term) {
    message_library_threat_term_update_alias($term, $op, $options);
  }

  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($tids), 'Updated URL alias for 1 threat term.', 'Updated URL aliases for @count threat terms.'));
  }
}
