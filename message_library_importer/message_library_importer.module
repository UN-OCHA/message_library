<?php
/**
 * @file
 */

include_once 'message_library_importer.features.inc';

/**
 * Implements hook_cron()
 */
function message_library_importer_cron() {
  return;
  $queue = DrupalQueue::get('message_library_importer');

  $items = array(
    'message_library_term_hazard' => 'hazard',
    'message_library_term_issues' => 'issues',
    'message_library_term_sector' => 'sector',
    'message_library_node_message' => 'message',

    'message_library_term_information_type' => 'information-type',
    'message_library_term_at_risk_group' => 'at-risk-group',
    'message_library_term_target_audience' => 'target-audience',
    'message_library_term_threat' => 'threat',
  );

  foreach ($items as $importer_id => $filename) {
    $queue->createItem(compact('importer_id', 'filename'));
  }

  while ($item = $queue->claimItem()) {
    message_library_importer_import_from_remote_csv($item);
  }
}

/**
 * Implements hook_cron_queue_info()
 */
function message_library_importer_cron_queue_info() {
  return;
  $queues = array();
  $queues['message_library_importer'] = array(
    'worker callback' => 'message_library_importer_import_from_remote_csv',
    'time' => 60,
  );
  return $queues;
}

function message_library_importer_import_from_remote_csv($item) {
  $FeedsSource = feeds_source($item->data['importer_id']);
  $config = $FeedsSource->getConfig();

  if (empty($config['FeedsHTTPFetcher']['source'])) {
    $config['FeedsHTTPFetcher']['source'] = 'http://infoasaid.org/message-library-export/' . $item->data['filename'];
    $FeedsSource->setConfig($config);
    $FeedsSource->save();
  }

  $batch = array(
    'title' => dt('Importing !feed_name', array('!feed_name' => $feed_name)),
    'operations' => array(
      array('feeds_batch', array('import', $feed_name, $feed_nid)),
    ),
  );
  batch_set($batch);
  $FeedsSource->startImport();
}

/**
 * Implements hook_feeds_processor_targets_alter()
 */
function message_library_importer_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  // dpm(func_get_args());
}

/**
 * Implements hook_feeds_after_parse()
 *
 * Invoked after a feed source has been parsed, before it will be processed.
 */
function message_library_importer_feeds_after_parse(FeedsSource $source, FeedsParserResult $result) {
  if (empty($result->items)) return;

  // The order of the terms to be processed matters, it will decide whether
  // the parent/child relationship will be properly set up. We do some custom
  // processing here to put the term with the highest hierarchy to the top of
  // list, the the lowest to the bottom.
  $checklist = array(
    'message_library_term_at_risk_group',
    'message_library_term_hazard',
    'message_library_term_information_type',
    'message_library_term_issues',
    'message_library_term_sector',
    'message_library_term_target_audience',
  );

  if (in_array($source->id, $checklist)) {
    $term_tree = message_library_importer_parsed_term_items_build_tree($result->items, 0);
    $sorted_tids = (message_library_importer_parsed_term_items_extract_tids($term_tree));

    // Sort it
    $sorted_terms = array_flip($sorted_tids);
    foreach ($result->items as $key => $item) {
      if (array_key_exists($item['term id'], $sorted_terms)) {
        $sorted_terms[$item['term id']] = $item;
        unset($result->terms[$key]);
      }
    }

    $result->items = $sorted_terms;
  }

  if ($source->id == 'message_library_term_threat') {
    // Threat -> Hazard
    // Threat -> Issues
    // Threat -> Sector
  }

  if ($source->id == 'message_library_node_message') {
    array_walk($result->items, 'message_library_import_map_message_node_field');
  }
}

/**
 * Implemements hook_feeds_presave()
 * This hook is invoked before a feed item is saved.
 */
function message_library_importer_feeds_presave(FeedsSource $source, $entity, $item) {
  $entity->field_message_source = array();
  if (!empty($item['source'])) {
    foreach ($item['source'] as $link) {
      $entity->field_message_source[LANGUAGE_NONE][] = $link;
    }
  }
}

/**
 * Callback for grouping the parsed terms by hierarchy
 */
function message_library_importer_parsed_term_items_build_tree($items, $parent) {
  $result = array();

  foreach ($items as $item) {
    if ($item['parent term id'] == $parent) {
      $new_item = $item;
      $new_item['children'] = message_library_importer_parsed_term_items_build_tree($items, $new_item['term id']);
      $result[] = $new_item;
    }
  }
  return !empty($result) ? $result : NULL;
}

/**
 * Callback for flattening the terms nested by hierarchy
 */
function message_library_importer_parsed_term_items_extract_tids($children) {
  $result = array();
  // Outter
  foreach ($children as $child) {
    $result[] = $child['term id'];
  }
  // Inner
  foreach ($children as $child) {
    if (!empty($child['children'])) {
      $result = array_merge($result, message_library_importer_parsed_term_items_extract_tids($child['children']));
    }
  }
  return $result;
}


function message_library_importer_map_term_names_to_ids(&$item, $index) {
  $item = $item;
}

/**
 * Callback for mapping fields
 */
function message_library_import_map_message_node_field(&$value, $index) {
  // Sensitivity field
  $mapping = array(
    'Not sensitive' => 0,
    'Sensitive' => 1,
    'Very sensitive' => 2,
  );

  if (!empty($value['sensitivity'])) {
    $old_label = $value['sensitivity'];

    if (array_key_exists($old_label, $mapping)) {
      $value['sensitivity'] = $mapping[$old_label];
    }

    // 'Alert Questions' - The feeds tamper remove the quesition mark and
    // add a empty option. Fix it here.
    if ($value['sensitivity'] == 2 && !empty($value['alert questions'])) {
      foreach ($value['alert questions'] as $key => $question) {
        if (empty($question)) {
          unset($value['alert questions'][$key]);
        }
        else {
          if (substr_compare($question, '?', -1) != 0) {
            $value['alert questions'][$key] .= '?';
          }
        }
      }
    }
  }

  // Process 'Source' field
  if (!empty($value['source'])) {
    $json_raw = $value['source'];
    $json_raw = str_replace("'", '"', $json_raw);
    $result = json_decode($json_raw, true);

    if (!empty($result)) {
      $value['source'] = array();
      foreach ($result as $key => $link) {
        $value['source'][$key] = $link;
      }
    }
  }
}
