<?php
/**
 * @file
 */

include_once 'message_library_importer.features.inc';

/**
 * Implements hook_menu()
 */
function message_library_importer_menu() {
  $items['admin/config/message_library/importer'] = array(
    'title' => 'Feeds Importer',
    'description' => 'Configuration on the Feeds importer for Message Library',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('message_library_importer_admin_form'),
    'access arguments' => array('access administration pages'),
    'file' => 'message_library_importer.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_cron()
 */
function message_library_importer_cron() {
  // Enable the option to wipe content before importing.
  //if (variable_get('ml_importer_wipe_content', FALSE)) {
    message_library_importer_clear_out_content();
  //}

  // Let feeds run as long he wishes...
  drupal_set_time_limit(0);
  variable_set('ml_importer_cron_last_run', REQUEST_TIME);

  $items = array(
    // These 3 vocabularies are required by `threat` terms
    // @see: admin/structure/taxonomy/threat/fields
    array('message_library_term_hazard' => 'hazard'),
    array('message_library_term_issues' => 'issues'),
    array('message_library_term_sector' => 'sector'),

    // Import threat (after the above 3 vocabularies imported)
    array('message_library_term_threat' =>  'threat'),
    array('message_library_term_information_type' => 'information-type'),
    array('message_library_term_at_risk_group' => 'at-risk-group'),
    array('message_library_term_target_audience' => 'target-audience'),

    // Import message (after the above 4 vocabularies imported)
    // @see: admin/structure/types/manage/message/fields
    array('message_library_node_message' => 'message'),
  );

  $queue = DrupalQueue::get('message_libary_importer', TRUE);
  $queue->deleteQueue();
  foreach ($items as $item) {
    $queue->createItem($item);
  }
}

/**
 * Implements hook_cron_queue_info()
 */
function message_library_importer_cron_queue_info() {
  return array(
    'message_libary_importer' => array(
      'worker callback' => 'message_library_importer_importer_feed_task',
      'time' => 240, // in seconds
    )
  );
}

/**
 * Batch operation
 */
function message_library_importer_importer_feed_task($item) {
  $feed_id = key($item);
  $url_suffix = current($item);

  $feed_source = feeds_source($feed_id);
  // Set the URL for the fetch
  $feed_url = variable_get('ml_importer_base_url', 'http://staging.infoasaid.org/message-library-export/') . $url_suffix;
  $config = $feed_source->getConfig();
  $config['FeedsHTTPFetcher']['source'] = $feed_url;
  $feed_source->setConfig($config);
  $feed_source->save();
  $feed_source->startImport();

  $feed_source->schedule();
  $feed_source->importer->schedule();

  if ($feed_id == 'message_library_node_message') {
    _message_library_importer_remove_empty_terms_and_content();
  }
}


/**
 * Implements hook_feeds_processor_targets_alter()
 */
function message_library_importer_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  // dpm(func_get_args());
}

/**
 * Implements hook_feeds_after_parse()
 *
 * Invoked after a feed source has been parsed, before it will be processed.
 */
function message_library_importer_feeds_after_parse(FeedsSource $source, FeedsParserResult $result) {
  if (empty($result->items)) return;

  // The order of the terms to be processed matters, it will decide whether
  // the parent/child relationship will be properly set up. We do some custom
  // processing here to put the term with the highest hierarchy to the top of
  // list, the the lowest to the bottom.
  $checklist = array(
    'message_library_term_at_risk_group',
    'message_library_term_hazard',
    'message_library_term_information_type',
    'message_library_term_issues',
    'message_library_term_sector',
    'message_library_term_target_audience',
  );
  if (in_array($source->id, $checklist)) {
    $term_tree = message_library_importer_parsed_term_items_build_tree($result->items, 0);
    $sorted_tids = (message_library_importer_parsed_term_items_extract_tids($term_tree));

    // Sort it
    $sorted_terms = array_flip($sorted_tids);
    foreach ($result->items as $key => $item) {
      if (array_key_exists($item['term id'], $sorted_terms)) {
        $sorted_terms[$item['term id']] = $item;
        unset($result->terms[$key]);
      }
    }

    $result->items = $sorted_terms;
  }
  elseif ($source->id == 'message_library_term_threat') {
    // Threat -> Hazard
    // Threat -> Issues
    // Threat -> Sector
  }
  elseif ($source->id == 'message_library_node_message') {
    array_walk($result->items, '_message_library_importer_map_message_node_field');
  }
}

/**
 * Implemements hook_feeds_presave()
 * This hook is invoked before a feed item is saved.
 */
function message_library_importer_feeds_presave(FeedsSource $source, $entity, $item) {
  // Set the right target for field 'field_message_source'
  // Only for message nodes
  if ($entity->nid && $entity->type && $entity->type == 'message') {
    $field_lan = field_language('node', $entity, 'field_message_source');
    $entity->field_message_source = array();
    if (!empty($item['source'])) {
      foreach ($item['source'] as $entry) {
        $entry = array_map('trim', $entry);

        $entity->field_message_source[$field_lan][] = array(
          'title' => $entry['title'],
          'url' => $entry['url'],
        );
      }
    }
  }
}

/**
 * Callback for grouping the parsed terms by hierarchy
 */
function message_library_importer_parsed_term_items_build_tree($items, $parent) {
  $result = array();

  foreach ($items as $item) {
    if ($item['parent term id'] == $parent) {
      $new_item = $item;
      $new_item['children'] = message_library_importer_parsed_term_items_build_tree($items, $new_item['term id']);
      $result[] = $new_item;
    }
  }
  return !empty($result) ? $result : NULL;
}

/**
 * Callback for flattening the terms nested by hierarchy
 */
function message_library_importer_parsed_term_items_extract_tids($children) {
  $result = array();
  // Outter
  foreach ($children as $child) {
    $result[] = $child['term id'];
  }
  // Inner
  foreach ($children as $child) {
    if (!empty($child['children'])) {
      $result = array_merge($result, message_library_importer_parsed_term_items_extract_tids($child['children']));
    }
  }
  return $result;
}

/**
 * Callback for mapping fields
 */
function _message_library_importer_map_message_node_field(&$value, $index) {
  // Sensitivity field
  $mapping = array(
    'no guidance required' => 0,
    'guidance required/sensitive' => 1,
    'highly sensitive' => 2,
  );

  if (!empty($value['sensitivity'])) {
    $old_label = trim(strtolower($value['sensitivity']));

    if (array_key_exists($old_label, $mapping)) {
      $value['sensitivity'] = $mapping[$old_label];
    }

    // 'Alert Questions' - The feeds tamper remove the quesition mark and
    // add a empty option. Fix it here.
    $value['alert questions'] = array_map('trim', $value['alert questions']);
    $value['alert questions'] = array_filter($value['alert questions']);
    if ($value['sensitivity'] == 2 && !empty($value['alert questions'])) {
      foreach ($value['alert questions'] as $key => $question) {
        if (empty($question)) {
          unset($value['alert questions'][$key]);
        }
        else {
          if (substr_compare($question, '?', -1) != 0) {
            $value['alert questions'][$key] .= '?';
          }
        }
      }
    }
  }

  // Process link fields, Source and Websites
  $link_fields = array(
    'source',
    'websites',
  );

  foreach ($link_fields as $link_field) {
    $value[$link_field] = trim($value[$link_field]);
    if (!empty($value[$link_field])) {
      $json_raw = $value[$link_field];
      // The json string must use double quotes, and the exported csv have double
      // quotes as wrappe. So the double string of the json string is turned into
      // single quotes in the master instance's csv export preprocessor
      $json_raw = preg_replace("/'(?=[:|,|}])/",  '"', $json_raw);
      $json_raw = preg_replace("/(?<=[:|,|{])'/", '"', $json_raw);

      $result = json_decode($json_raw, true);

      if (!empty($result)) {
        $value[$link_field] = array();
        foreach ($result as $key => $item) {
          $value[$link_field][] = $item;
        }
      }
      else {
        // @todo: Log this?
        $value[$link_field] = array();
      }
    }
  }

  // Process the attachment fields
  $example = trim($value['examples of communication around this issue']);
  $value['examples of communication around this issue'] = array();
  if (!empty($example)) {
    $example_items = explode(',', $example);

    if (!empty($example_items)) {
      foreach ($example_items as $item) {
        $item = trim($item);
        if (link_validate_url($item) != FALSE) {
          $value['examples of communication around this issue'][] = array(
            'url' => $item,
            'title' => '',
          );
        }
        else {
          // @TODO: Log this
        }
      }
    }
  }
}

/**
 * Clear out all the content imported by message-library
 * This will clean up the following content:
 * + Taxonomy terms in vocabulary:
 *   - at_risk_groups
 *   - hazard
 *   - information_type
 *   - issues
 *   - sector
 *   - target_audience
 *   - threat
 * + Nodes of content type:
 *   - message
 */
function message_library_importer_clear_out_content() {
  // Clear all the content of type: Message
  $node_types = array('message');

  $results = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('type', $node_types, 'IN')
    ->execute();
  foreach ($results as $result) {
    $nids[] = $result->nid;
  }

  if (!empty($nids)) {
    node_delete_multiple($nids);
  }

  // Clear all the terms of vocabulary:
  // - 'At Risk Group'
  // - 'Target Audience'
  // - 'Information Type'
  // - â€™Hazard'
  // - 'Issues'
  // - 'Sector'
  // - 'Threat'
  $vocabularies = array(
    'at_risk_groups',
    'hazard',
    'information_type',
    'issues',
    'sector',
    'target_audience',
    'threat',
  );

  $vocabs = array();
  foreach($vocabularies as $vocab_name) {
    $vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
    if (empty($vocab)) {
      continue;
    }
    $vocabs[$vocab->vid] = $vocab;
  }
  $vids = array_keys($vocabs);

  $tids = db_select('taxonomy_term_data', 'td')
    ->fields('td', array('tid'))
    ->condition('vid', $vids, 'IN')
    ->orderBy('tid', 'ASC')
    ->execute()
    ->fetchCol('tid');

  foreach ($tids as $tid) {
    taxonomy_term_delete($tid);
  }
}

/**
 * Remove the empty tersm and content
 */
function _message_library_importer_remove_empty_terms_and_content() {
  // The vocabulary to check
  $vocabs = array(
    'hazard',
    'issues',
    'sector',
    'information_type',
    'at_risk_groups',
    'target_audience',
    'threat'
  );

  // The content types to check
  $cts = array(
    'message',
  );

  foreach($vocabs as $vocab_name) {
    $vocab_obj = taxonomy_vocabulary_machine_name_load($vocab_name);
    if (empty($vocab_obj)) {
      continue;
    }

    $terms = taxonomy_get_tree($vocab_obj->vid, 0, NULL, TRUE);
    foreach ($terms as $term) {
      if (!empty($term->name)) {
        continue;
      }

      // Check if there are some node referencing it
      $nodes = taxonomy_select_nodes($term->tid);
      $rs = taxonomy_term_delete($term->tid);
    }
  }
}
