<?php

/**
 * @file
 *
 * The intention of the module is that it provides a place to possibly arrange
 * the order of all the message nodes under a threat.
 */

/**
 * Implements hook_flush_caches()
 */
function message_library_queue_flush_caches() {
  message_library_queue_reset_queue();
}

/**
 * Prepopulate the system with a basic queue:
 *
 * - A umbrella nodequeue - 'message_library_queue'
 * - Many subqueues under it, each subqueue represents a threat term
 * - Fill each subqueue with the messages for that threat
 */
function message_library_queue_reset_queue() {
  $queue_name = 'message_library_threat';
  nodequeue_delete($queue_name);

  // Create the nodequeue
  $nodequeue = new stdClass();
  $nodequeue->name = 'message_library_threat';
  $nodequeue->title = 'Message Library Threat';
  $nodequeue->subqueue_title = '';
  $nodequeue->size = 0;
  $nodequeue->link = 'Add message';
  $nodequeue->link_remove = 'Remove message';
  $nodequeue->owner = 'nodequeue';
  $nodequeue->show_in_links = 1;
  $nodequeue->show_in_tab = 1;
  $nodequeue->show_in_ui = 1;
  $nodequeue->reference = '0';
  $nodequeue->reverse = 0;
  $nodequeue->i18n = 0;
  $nodequeue->roles = array();
  $nodequeue->types = array('message');
  nodequeue_save($nodequeue);

  // Create the sub-nodequeues
  $vocab = taxonomy_vocabulary_machine_name_load('threat');
  if (!empty($vocab)) {
    $vid = $vocab->vid;
    $terms = taxonomy_get_tree($vid, 0, NULL, TRUE);

    if (!empty($terms)) {
      foreach ($terms as $term) {
        $subqueue = nodequeue_add_subqueue($nodequeue, $term->name, $term->tid);

        // Fill the sub-nodequeues with messages
        $message_nids = message_library_get_messages_by_threat_tid($term->tid);
        foreach ($message_nids as $nid) {
          nodequeue_subqueue_add($nodequeue, $subqueue, $nid);
        }
      }
    }
  }
}

/**
 * Implements hook_taxonomy_term_delete()
 *
 * Every time a new threat term is deleted, automatically delete the subqueue
 * for it
 */
function message_library_queue_taxonomy_term_delete($term) {
  // Act on a new threat term deleted
  $vocab = taxonomy_vocabulary_machine_name_load('threat');
  if (!empty($vocab->vid) && !empty($term->vid) && ($term->vid == $vocab->vid)) {
    // Check whether a queue exists for this term
    $result = db_select('nodequeue_subqueue', 's')
      ->fields('s')
      ->condition('name', 'message_library_threat')
      ->condition('reference', $term->tid)
      ->execute()
      ->fetchAllAssoc('sqid');

    if (!empty($result)) {
      foreach ($result as $item) {
        if (!empty($item->sqid)) {
          nodequeue_remove_subqueue($item->sqid);
        }
      }
    }
  }
}

/**
 * Implements hook_taxonomy_term_insert()
 *
 * Every time a new threat term is inserted, automatically create a new subqueue
 * for it
 */
function message_library_queue_taxonomy_term_insert($term) {
  // Act on a new threat term created
  $vocab = taxonomy_vocabulary_machine_name_load('threat');
  if (!empty($vocab->vid)) {
    $threat_vid = $vocab->vid;
    if (!empty($term->vid) && $term->vid == $threat_vid) {
      message_library_queue_add_subqueue_for_term($term);
    }
  }
}

/**
 * Add a subqueue for a threat
 */
function message_library_queue_add_subqueue_for_term($term) {
  if (is_int($term)) {
    $term = taxonomy_term_load($term);
  }

  $parent_queue = nodequeue_load('message_library_threat');
  if (!empty($parent_queue)) {
    $subqueue = nodequeue_add_subqueue($parent_queue, $term->name, $term->tid);
    // Fill with messages
    $message_nids = message_library_get_messages_by_threat_tid($term->tid);
    foreach ($message_nids as $nid) {
      nodequeue_subqueue_add($parent_queue, $subqueue, $nid);
    }
  }
}

/**
 * Remove a subqueue for a threat
 */
function message_library_queue_remove_subqueue_for_term($term) {
  if (is_int($term)) {
    $term = taxonomy_term_load($term);
  }
}

/**
 * Implements hook_nodequeue_delete()
 */
function message_library_queue_nodequeue_delete($name) {
  // XXX: Don't know why the nodequeue_delete() doesn't clear the data
  if ($name == 'message_library_threat') {
    db_query("DELETE FROM {nodequeue_types} WHERE name = ':name'", array(':name' => $name));
    db_query("DELETE FROM {nodequeue_subqueue} WHERE name = ':name'", array(':name' => $name));
    db_query("DELETE FROM {nodequeue_nodes} WHERE name = ':name'", array(':name' => $name));
    db_query("DELETE FROM {nodequeue_queue} WHERE name = ':name'", array(':name' => $name));
    db_query("DELETE FROM {nodequeue_roles} WHERE name = ':name'", array(':name' => $name));
  }
}
